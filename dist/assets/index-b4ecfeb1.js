var L=Object.defineProperty;var M=(n,e,t)=>e in n?L(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var a=(n,e,t)=>(M(n,typeof e!="symbol"?e+"":e,t),t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const r of o.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&i(r)}).observe(document,{childList:!0,subtree:!0});function t(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function i(s){if(s.ep)return;s.ep=!0;const o=t(s);fetch(s.href,o)}})();class z{constructor(){a(this,"layers");this.layers=[]}draw(e,t){this.layers.forEach(i=>{i(e,t)})}}class A{constructor(){a(this,"grid");this.grid=[]}forEach(e){this.grid.forEach((t,i)=>{t.forEach((s,o)=>{e(s,i,o)})})}get(e,t){const i=this.grid[e];if(i)return i[t]}set(e,t,i){this.grid[e]||(this.grid[e]=[]),this.grid[e][t]=i}}class p{constructor(e,t){a(this,"x");a(this,"y");this.set(e,t)}set(e,t){this.x=e,this.y=t}}const x=16,E={x:64,y:64},y={w:14,h:16},N=2e3,C=!0,O=!1,w={SPACE:"Space",ARROW_RIGHT:"ArrowRight",ARROW_LEFT:"ArrowLeft"},b=256+16,k=256;class P{constructor(e,t=x){a(this,"matrix");a(this,"tileSize");this.matrix=e,this.tileSize=t}toIndex(e){return~~(e/this.tileSize)}toIndexRange(e,t){const i=~(t/this.tileSize)*this.tileSize,s=[];let o=e;do s.push(this.toIndex(o)),o+=this.tileSize;while(o<i);return s}getByIndex(e,t){const i=this.matrix.get(e,t);if(i){const s=e*this.tileSize,o=s+this.tileSize,r=t*this.tileSize,c=r+this.tileSize;return{tile:i,x1:s,x2:o,y1:r,y2:c}}}searchByPosition(e,t){return this.getByIndex(this.toIndex(e),this.toIndex(t))}searchByRange(e,t,i,s){const o=[];return this.toIndexRange(e,t).forEach(r=>{this.toIndexRange(i,s).forEach(c=>{const l=this.getByIndex(r,c);l&&o.push(l)})}),o}}class _{constructor(e){a(this,"tiles");this.tiles=new P(e)}checkX(e){let t;if(e.vel.x>0)t=e.pos.x+e.size.x;else if(e.vel.x<0)t=e.pos.x;else return;this.tiles.searchByRange(t,t,e.pos.y,e.pos.y+e.size.y).forEach(s=>{s.tile.type==="ground"&&(e.vel.x>0?e.pos.x+e.size.x>s.x1&&(e.pos.x=s.x1-e.size.x,e.vel.x=0):e.vel.x<0&&e.pos.x<s.x2&&(e.pos.x=s.x2,e.vel.x=0))})}checkY(e){let t;if(e.vel.y>0)t=e.pos.y+e.size.y;else if(e.vel.y<0)t=e.pos.y;else return;this.tiles.searchByRange(e.pos.x,e.pos.x+e.size.x,t,t).forEach(s=>{s.tile.type==="ground"&&(e.vel.y>0?e.pos.y+e.size.y>s.y1&&(e.pos.y=s.y1-e.size.y,e.vel.y=0):e.vel.y<0&&e.pos.y<s.y2&&(e.pos.y=s.y2,e.vel.y=0))})}test(e){this.checkY(e)}}class B{constructor(){a(this,"comp");a(this,"entities");a(this,"tiles");a(this,"tileCollider");a(this,"totalTime");this.totalTime=0,this.comp=new z,this.entities=new Set,this.tiles=new A,this.tileCollider=new _(this.tiles)}update(e){this.entities.forEach(t=>{t.update(e),t.pos.x+=t.vel.x*e,this.tileCollider.checkX(t),t.pos.y+=t.vel.y*e,this.tileCollider.checkY(t),t.vel.y+=N*e}),this.totalTime+=e}}class D{constructor(e,t,i){a(this,"image");a(this,"width");a(this,"height");a(this,"tiles");a(this,"animation");this.image=e,this.width=t,this.height=i,this.tiles=new Map,this.animation=new Map}defineAnim(e,t){this.animation.set(e,t)}define(e,t,i,s,o){const r=[!1,!0].map(c=>{const l=document.createElement("canvas");l.width=s,l.height=o;const d=l.getContext("2d");return c&&(d.scale(-1,1),d.translate(-s,0)),d.drawImage(this.image,t,i,s,o,0,0,s,o),l});this.tiles.set(e,r)}defineTile(e,t,i){this.define(e,t*this.width,i*this.height,this.width,this.height)}draw(e,t,i,s,o=!1){const r=this.tiles.get(e);r&&t.drawImage(r[Number(o)],i,s)}drawAnim(e,t,i,s,o){const r=this.animation.get(e);r&&this.drawTile(r(o),t,i,s)}drawTile(e,t,i,s){this.draw(e,t,i*this.width,s*this.height)}}class v{constructor(e){a(this,"NAME");this.NAME=e}update(e,t){console.warn("Unhandled update call in Trait")}}class F{constructor(){a(this,"pos");a(this,"vel");a(this,"size");a(this,"traits");a(this,"draw");this.pos=new p(0,0),this.vel=new p(0,0),this.size=new p(0,0),this.traits=[]}addTrait(e){this.traits.push(e),this[e.NAME]=e}update(e){this.traits.forEach(t=>{t.update(this,e)})}}class W{constructor(){a(this,"keyStates");a(this,"keyMap");this.keyStates=new Map,this.keyMap=new Map}addMapping(e,t){this.keyMap.set(e,t)}handleEvent(e){const{code:t}=e;if(!this.keyMap.has(t))return;e.preventDefault();const i=e.type==="keydown"?C:O;this.keyStates.get(t)!==i&&(this.keyStates.set(t,i),this.keyMap.get(t)(i))}listenTo(e){["keydown","keyup"].forEach(i=>{e.addEventListener(i,s=>{this.handleEvent(s)})})}}class j extends v{constructor(){super("go");a(this,"dir");a(this,"speed");a(this,"distance");a(this,"heading");this.dir=0,this.speed=6e3,this.distance=0,this.heading=1}update(t,i){t.vel.x=this.speed*this.dir*i,this.dir?(this.heading=this.dir,this.distance+=Math.abs(t.vel.x)*i):this.distance=0}}class H extends v{constructor(){super("jump");a(this,"duration");a(this,"velocity");a(this,"engageTime");this.duration=.5,this.engageTime=0,this.velocity=200}start(){this.engageTime=this.duration}cancel(){this.engageTime=0}update(t,i){this.engageTime>0&&(t.vel.y=-this.velocity,this.engageTime-=i)}}const S=function(n,e){return function(i){const s=Math.floor(i/e)%n.length;return n[s]}},Y=async function(){const n=await T("mario"),e=new F;e.size.set(y.w,y.h),e.addTrait(new j),e.addTrait(new H);const i=S(["run-1","run-2","run-3"],10);function s(o){return o.go.dir===0?"idle":i(o.go.distance)}return e.draw=function(r){n.draw(s(this),r,0,0,e.go.heading<0)},e},I=async function(n){return fetch(n).then(e=>e.json())},q=function(n){const e=new W;return e.addMapping(w.SPACE,t=>{t?n.jump.start():n.jump.cancel()}),e.addMapping(w.ARROW_RIGHT,t=>{n.go.dir=+t}),e.addMapping(w.ARROW_LEFT,t=>{n.go.dir=-t}),e};function G(n,e,t){const i=["mousedown","mousemove"];let s;i.forEach(o=>{n.addEventListener(o,r=>{r.buttons===1?(e.vel.set(0,0),e.pos.set(r.offsetX+t.pos.x,r.offsetY+t.pos.y)):r.buttons===2&&s&&s.buttons===2&&s.type==="mousemove"&&(t.pos.x-=r.offsetX-s.offsetX),s=r})}),n.addEventListener("contextmenu",o=>o.preventDefault())}const K=function(n,e){const t=n.tiles,i=n.tileCollider.tiles,s=document.createElement("canvas");s.width=b,s.height=k;const o=s.getContext("2d");let r,c;function l(d,u){r=d,c=u,console.log("redrawing");for(let h=r;h<=c;++h){const m=t.grid[h];m&&m.forEach((f,g)=>{e.animation.has(f.name)?e.drawAnim(f.name,o,h-r,g,n.totalTime):e.drawTile(f.name,o,h-r,g)})}}return function(u,h){const m=i.toIndex(h.size.x),f=i.toIndex(h.pos.x),g=f+m;l(f,g),u.drawImage(s,-h.pos.x%x,-h.pos.y)}},X=function(n,e=64,t=64){const i=document.createElement("canvas");i.width=e,i.height=t;const s=i.getContext("2d");return function(r,c){n.forEach(l=>{s.clearRect(0,0,e,t),l.draw(s),r.drawImage(i,l.pos.x-c.pos.x,l.pos.y-c.pos.y)})}},J=function(n){return new Promise(e=>{const t=new Image;t.addEventListener("load",()=>{e(t)}),t.src=n})},U=function(n,e){function t(i,s,o,r,c){const l=s+o,d=r+c;for(let u=s;u<l;++u)for(let h=r;h<d;++h)n.tiles.set(u,h,{name:i.tile,type:i.type})}e.forEach(i=>{i.ranges.forEach(s=>{if(s.length===4){const[o,r,c,l]=s;t(i,o,r,c,l)}else if(s.length===3){const[o,r,c]=s;t(i,o,r,c,1)}else if(s.length===2){const[o,r]=s;t(i,o,1,r,1)}})})},T=async function(n){var s,o,r;const e=await I(`/@sprites/${n}.json`),t=await J(e.imageURL),i=new D(t,e.tileW||x,e.tileH||x);return(s=e.tiles)==null||s.forEach(c=>{i.defineTile(c.name,c.index[0],c.index[1])}),(o=e.frames)==null||o.forEach(c=>{i.define(c.name,...c.rect)}),(r=e.animations)==null||r.forEach(c=>{const l=S(c.frames,c.frameLen);i.defineAnim(c.name,l)}),i},V=async function(n){const e=await I(`/@levels/${n}.json`),t=await T(e.spritesheet),i=new B;U(i,e.backgrounds);const s=K(i,t);i.comp.layers.push(s);const o=X(i.entities);return i.comp.layers.push(o),i};class Z{constructor(e=1/60){a(this,"update");a(this,"updateProxy");let t=0,i=0;this.updateProxy=s=>{for(t+=(s-i)/1e3,t>1&&(t=1);t>e;)this.update(e),t-=e;i=s,this.enqueue()}}enqueue(){requestAnimationFrame(this.updateProxy)}start(){this.enqueue()}}class ${constructor(){a(this,"pos");a(this,"size");this.pos=new p(0,0),this.size=new p(256,256)}}const R=document.getElementById("screen"),Q=R.getContext("2d");Promise.all([Y(),V("1-1")]).then(([n,e])=>{const t=new $;n.pos.set(E.x,E.y),e.entities.add(n),q(n).listenTo(window),G(R,n,t);const s=new Z;s.update=function(r){e.update(r),e.comp.draw(Q,t)},s.start()});
